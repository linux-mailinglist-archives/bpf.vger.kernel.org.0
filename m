Return-Path: <bpf+bounces-36334-lists+bpf=lfdr.de@vger.kernel.org>
X-Original-To: lists+bpf@lfdr.de
Delivered-To: lists+bpf@lfdr.de
Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org [139.178.88.99])
	by mail.lfdr.de (Postfix) with ESMTPS id 34AAA9466F5
	for <lists+bpf@lfdr.de>; Sat,  3 Aug 2024 04:59:51 +0200 (CEST)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sv.mirrors.kernel.org (Postfix) with ESMTPS id E378E282DA3
	for <lists+bpf@lfdr.de>; Sat,  3 Aug 2024 02:59:49 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 5FF1FC8DF;
	Sat,  3 Aug 2024 02:59:45 +0000 (UTC)
X-Original-To: bpf@vger.kernel.org
Received: from 69-171-232-181.mail-mxout.facebook.com (69-171-232-181.mail-mxout.facebook.com [69.171.232.181])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 3D23F187F
	for <bpf@vger.kernel.org>; Sat,  3 Aug 2024 02:59:39 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=69.171.232.181
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1722653985; cv=none; b=L260Za8KiviB3nGeP/J6LqGPn528fUUnvoogjNlusB4Tm0AXDduM5BSl/+zyqZRaMS7DD4WuEPBHMPcbLCVv5t86qMU0D6njv0TqKJ0JtWq5KQwGhU1TnXkeBfVLajIeAza19BTYw2GDAAfewoVVnEQxWfOxLFV+oxk5WUjGqmA=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1722653985; c=relaxed/simple;
	bh=cHqx3DJP/e9L/eoBYqJdStrm+lXmW9tAT9CE12tLNZw=;
	h=From:To:Cc:Subject:Date:Message-ID:MIME-Version; b=J253H1p7QmQ62Zb0NifQ8ZALJcnUT88+OZ+bLf+0OGYDSvW6CDUkeqy4qwp9y93kH3MnBHzGoYaVKQSxJ5yhh4Pu1oyWJ2yJr00/bJ7yb0KzxPpcBUBd5o685C5wkFG+5xhC9cyBXmSG7tgU+U1x5Z5DIGuya//1oOkIJlJCKxQ=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=fail (p=none dis=none) header.from=linux.dev; spf=fail smtp.mailfrom=linux.dev; arc=none smtp.client-ip=69.171.232.181
Authentication-Results: smtp.subspace.kernel.org; dmarc=fail (p=none dis=none) header.from=linux.dev
Authentication-Results: smtp.subspace.kernel.org; spf=fail smtp.mailfrom=linux.dev
Received: by devbig309.ftw3.facebook.com (Postfix, from userid 128203)
	id 4C3F274BFBA9; Fri,  2 Aug 2024 19:59:28 -0700 (PDT)
From: Yonghong Song <yonghong.song@linux.dev>
To: bpf@vger.kernel.org
Cc: Alexei Starovoitov <ast@kernel.org>,
	Andrii Nakryiko <andrii@kernel.org>,
	Daniel Borkmann <daniel@iogearbox.net>,
	kernel-team@fb.com,
	Martin KaFai Lau <martin.lau@kernel.org>
Subject: [PATCH bpf-next v2] selftests/bpf: Fix arena_atomics selftest failure due to llvm change
Date: Fri,  2 Aug 2024 19:59:28 -0700
Message-ID: <20240803025928.4184433-1-yonghong.song@linux.dev>
X-Mailer: git-send-email 2.43.0
Precedence: bulk
X-Mailing-List: bpf@vger.kernel.org
List-Id: <bpf.vger.kernel.org>
List-Subscribe: <mailto:bpf+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:bpf+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: quoted-printable

Peilen Ye reported an issue ([1]) where for __sync_fetch_and_add(...) wit=
hout
return value like
  __sync_fetch_and_add(&foo, 1);
llvm BPF backend generates locked insn e.g.
  lock *(u32 *)(r1 + 0) +=3D r2

If __sync_fetch_and_add(...) returns a value like
  res =3D __sync_fetch_and_add(&foo, 1);
llvm BPF backend generates like
  r2 =3D atomic_fetch_add((u32 *)(r1 + 0), r2)

But 'lock *(u32 *)(r1 + 0) +=3D r2' caused a problem in jit
since proper barrier is not inserted based on __sync_fetch_and_add() sema=
ntics.

The above discrepancy is due to commit [2] where it tries to maintain bac=
kward
compatability since before commit [2], __sync_fetch_and_add(...) generate=
s
lock insn in BPF backend.

Based on discussion in [1], now it is time to fix the above discrepancy s=
o we can
have proper barrier support in jit. llvm patch [3] made sure that __sync_=
fetch_and_add(...)
always generates atomic_fetch_add(...) insns. Now 'lock *(u32 *)(r1 + 0) =
+=3D r2' can only
be generated by inline asm. The same for __sync_fetch_and_and(), __sync_f=
etch_and_or()
and __sync_fetch_and_xor().

But the change in [3] caused arena_atomics selftest failure.

  test_arena_atomics:PASS:arena atomics skeleton open 0 nsec
  libbpf: prog 'and': BPF program load failed: Permission denied
  libbpf: prog 'and': -- BEGIN PROG LOAD LOG --
  arg#0 reference type('UNKNOWN ') size cannot be determined: -22
  0: R1=3Dctx() R10=3Dfp0
  ; if (pid !=3D (bpf_get_current_pid_tgid() >> 32)) @ arena_atomics.c:87
  0: (18) r1 =3D 0xffffc90000064000       ; R1_w=3Dmap_value(map=3Darena_=
at.bss,ks=3D4,vs=3D4)
  2: (61) r6 =3D *(u32 *)(r1 +0)          ; R1_w=3Dmap_value(map=3Darena_=
at.bss,ks=3D4,vs=3D4) R6_w=3Dscalar(smin=3D0,smax=3Dumax=3D0xffffffff,var=
_off=3D(0x0; 0xffffffff))
  3: (85) call bpf_get_current_pid_tgid#14      ; R0_w=3Dscalar()
  4: (77) r0 >>=3D 32                     ; R0_w=3Dscalar(smin=3D0,smax=3D=
umax=3D0xffffffff,var_off=3D(0x0; 0xffffffff))
  5: (5d) if r0 !=3D r6 goto pc+11        ; R0_w=3Dscalar(smin=3D0,smax=3D=
umax=3D0xffffffff,var_off=3D(0x0; 0xffffffff)) R6_w=3Dscalar(smin=3D0,sma=
x=3Dumax=3D0xffffffff,var_off=3D(0x0; 0x)
  ; __sync_fetch_and_and(&and64_value, 0x011ull << 32); @ arena_atomics.c=
:91
  6: (18) r1 =3D 0x100000000060           ; R1_w=3Dscalar()
  8: (bf) r1 =3D addr_space_cast(r1, 0, 1)        ; R1_w=3Darena
  9: (18) r2 =3D 0x1100000000             ; R2_w=3D0x1100000000
  11: (db) r2 =3D atomic64_fetch_and((u64 *)(r1 +0), r2)
  BPF_ATOMIC stores into R1 arena is not allowed
  processed 9 insns (limit 1000000) max_states_per_insn 0 total_states 0 =
peak_states 0 mark_read 0
  -- END PROG LOAD LOG --
  libbpf: prog 'and': failed to load: -13
  libbpf: failed to load object 'arena_atomics'
  libbpf: failed to load BPF skeleton 'arena_atomics': -13
  test_arena_atomics:FAIL:arena atomics skeleton load unexpected error: -=
13 (errno 13)
  #3       arena_atomics:FAIL

The reason of the failure is due to [4] where atomic{64,}_fetch_{and,or,x=
or}() are not
allowed by arena addresses. Without llvm patch [3], the compiler will gen=
erate 'lock ...'
insn and everything will work fine.

This patch fixed the problem by using inline asms. Instead of __sync_fetc=
h_and_{and,or,xor}() functions,
the inline asm with 'lock' insn is used and it will work with or without =
[3].
Note that three bpf programs ('and', 'or' and 'xor') are guarded with __B=
PF_FEATURE_ADDR_SPACE_CAST
as well to ensure compilation failure for llvm <=3D 18 version. Note that=
 for llvm <=3D 18 where
addr_space_cast is not supported, all arena_atomics subtests are skipped =
with below message:
  test_arena_atomics:SKIP:no ENABLE_ATOMICS_TESTS or no addr_space_cast s=
upport in clang
  #3 arena_atomics:SKIP

  [1] https://lore.kernel.org/bpf/ZqqiQQWRnz7H93Hc@google.com/T/#mb68d67b=
c8f39e35a0c3db52468b9de59b79f021f
  [2] https://github.com/llvm/llvm-project/commit/286daafd65129228e08a1d0=
7aa4ca74488615744
  [3] https://github.com/llvm/llvm-project/pull/101428
  [4] d503a04f8bc0 ("bpf: Add support for certain atomics in bpf_arena to=
 x86 JIT")

Signed-off-by: Yonghong Song <yonghong.song@linux.dev>
---
 .../selftests/bpf/progs/arena_atomics.c       | 63 ++++++++++++++++---
 1 file changed, 54 insertions(+), 9 deletions(-)

Changelog:
  v1 -> v2:
    - Add __BPF_FEATURE_ADDR_SPACE_CAST to guard newly added asm codes fo=
r llvm >=3D 19

diff --git a/tools/testing/selftests/bpf/progs/arena_atomics.c b/tools/te=
sting/selftests/bpf/progs/arena_atomics.c
index bb0acd79d28a..dea54557fc00 100644
--- a/tools/testing/selftests/bpf/progs/arena_atomics.c
+++ b/tools/testing/selftests/bpf/progs/arena_atomics.c
@@ -5,6 +5,7 @@
 #include <bpf/bpf_tracing.h>
 #include <stdbool.h>
 #include "bpf_arena_common.h"
+#include "bpf_misc.h"
=20
 struct {
 	__uint(type, BPF_MAP_TYPE_ARENA);
@@ -85,10 +86,24 @@ int and(const void *ctx)
 {
 	if (pid !=3D (bpf_get_current_pid_tgid() >> 32))
 		return 0;
-#ifdef ENABLE_ATOMICS_TESTS
+#if defined(ENABLE_ATOMICS_TESTS) && defined(__BPF_FEATURE_ADDR_SPACE_CA=
ST)
=20
-	__sync_fetch_and_and(&and64_value, 0x011ull << 32);
-	__sync_fetch_and_and(&and32_value, 0x011);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[and64_value], 0, 1);"
+		"lock *(u64 *)(r1 + 0) &=3D %[val]"
+		:
+		: __imm_ptr(and64_value),
+		  [val]"r"(0x011ull << 32)
+		: "r1"
+	);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[and32_value], 0, 1);"
+		"lock *(u32 *)(r1 + 0) &=3D %[val]"
+		:
+		: __imm_ptr(and32_value),
+		  [val]"w"(0x011)
+		: "r1"
+	);
 #endif
=20
 	return 0;
@@ -102,9 +117,24 @@ int or(const void *ctx)
 {
 	if (pid !=3D (bpf_get_current_pid_tgid() >> 32))
 		return 0;
-#ifdef ENABLE_ATOMICS_TESTS
-	__sync_fetch_and_or(&or64_value, 0x011ull << 32);
-	__sync_fetch_and_or(&or32_value, 0x011);
+#if defined(ENABLE_ATOMICS_TESTS) && defined(__BPF_FEATURE_ADDR_SPACE_CA=
ST)
+
+	asm volatile(
+		"r1 =3D addr_space_cast(%[or64_value], 0, 1);"
+		"lock *(u64 *)(r1 + 0) |=3D %[val]"
+		:
+		: __imm_ptr(or64_value),
+		  [val]"r"(0x011ull << 32)
+		: "r1"
+	);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[or32_value], 0, 1);"
+		"lock *(u32 *)(r1 + 0) |=3D %[val]"
+		:
+		: __imm_ptr(or32_value),
+		  [val]"w"(0x011)
+		: "r1"
+	);
 #endif
=20
 	return 0;
@@ -118,9 +148,24 @@ int xor(const void *ctx)
 {
 	if (pid !=3D (bpf_get_current_pid_tgid() >> 32))
 		return 0;
-#ifdef ENABLE_ATOMICS_TESTS
-	__sync_fetch_and_xor(&xor64_value, 0x011ull << 32);
-	__sync_fetch_and_xor(&xor32_value, 0x011);
+#if defined(ENABLE_ATOMICS_TESTS) && defined(__BPF_FEATURE_ADDR_SPACE_CA=
ST)
+
+	asm volatile(
+		"r1 =3D addr_space_cast(%[xor64_value], 0, 1);"
+		"lock *(u64 *)(r1 + 0) ^=3D %[val]"
+		:
+		: __imm_ptr(xor64_value),
+		  [val]"r"(0x011ull << 32)
+		: "r1"
+	);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[xor32_value], 0, 1);"
+		"lock *(u32 *)(r1 + 0) ^=3D %[val]"
+		:
+		: __imm_ptr(xor32_value),
+		  [val]"w"(0x011)
+		: "r1"
+	);
 #endif
=20
 	return 0;
--=20
2.43.0


