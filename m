Return-Path: <bpf+bounces-58354-lists+bpf=lfdr.de@vger.kernel.org>
X-Original-To: lists+bpf@lfdr.de
Delivered-To: lists+bpf@lfdr.de
Received: from ny.mirrors.kernel.org (ny.mirrors.kernel.org [IPv6:2604:1380:45d1:ec00::1])
	by mail.lfdr.de (Postfix) with ESMTPS id A8656AB9085
	for <lists+bpf@lfdr.de>; Thu, 15 May 2025 22:06:57 +0200 (CEST)
Received: from smtp.subspace.kernel.org (relay.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-ECDSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by ny.mirrors.kernel.org (Postfix) with ESMTPS id 1195716EA03
	for <lists+bpf@lfdr.de>; Thu, 15 May 2025 20:06:58 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id 457BB25A633;
	Thu, 15 May 2025 20:06:52 +0000 (UTC)
X-Original-To: bpf@vger.kernel.org
Received: from 69-171-232-181.mail-mxout.facebook.com (69-171-232-181.mail-mxout.facebook.com [69.171.232.181])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id B05F41F78E0
	for <bpf@vger.kernel.org>; Thu, 15 May 2025 20:06:48 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=69.171.232.181
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1747339612; cv=none; b=YksNxi75UL76b3nN5YICzRpjXveH+A+IoM+cg9FYOThuZFtKPwVP+QOh61q7R0fNBZ8m5tZgbCXIkKXmBC2hAjTac6qKRBsgJjrWVKC8+/CsGHR+Ea+X37hUx9WN5KjX4yWkJcs7OD6lTGkFUjt60hFuIyUUcVB5jwFVmwVkoZs=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1747339612; c=relaxed/simple;
	bh=zFWT7oZR0u/28GiE11U0Cmvi0ePKvakXcWeGCkRNg+w=;
	h=From:To:Cc:Subject:Date:Message-ID:MIME-Version:Content-Type; b=hTQyGKMI9VKg+1jFVFlvezMJgAMsPxgU0V2HEFrvv9nNUAfTMjOt9bUbm5FbDMx57WIE90jC7FpqNIw4UDRun2rhBl1KWiGxQSFUMf8FttO3daN6dV05+XGRqkIsA5iTCbKvJKxW4VXbKQvqYO3SW5evlEPjKV0oMibZtB2SjuA=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=fail (p=none dis=none) header.from=linux.dev; spf=fail smtp.mailfrom=linux.dev; arc=none smtp.client-ip=69.171.232.181
Authentication-Results: smtp.subspace.kernel.org; dmarc=fail (p=none dis=none) header.from=linux.dev
Authentication-Results: smtp.subspace.kernel.org; spf=fail smtp.mailfrom=linux.dev
Received: by devvm16039.vll0.facebook.com (Postfix, from userid 128203)
	id C810E786E051; Thu, 15 May 2025 13:06:35 -0700 (PDT)
From: Yonghong Song <yonghong.song@linux.dev>
To: bpf@vger.kernel.org
Cc: Alexei Starovoitov <ast@kernel.org>,
	Andrii Nakryiko <andrii@kernel.org>,
	Daniel Borkmann <daniel@iogearbox.net>,
	kernel-team@fb.com,
	Martin KaFai Lau <martin.lau@kernel.org>
Subject: [PATCH bpf-next v2 1/2] bpf: Warn with new bpf_unreachable() kfunc maybe due to uninitialized var
Date: Thu, 15 May 2025 13:06:35 -0700
Message-ID: <20250515200635.3427478-1-yonghong.song@linux.dev>
X-Mailer: git-send-email 2.47.1
Precedence: bulk
X-Mailing-List: bpf@vger.kernel.org
List-Id: <bpf.vger.kernel.org>
List-Subscribe: <mailto:bpf+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:bpf+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

Marc Su=C3=B1=C3=A9 (Isovalent, part of Cisco) reported an issue where an
uninitialized variable caused generating bpf prog binary code not
working as expected. The reproducer is in [1] where the flags
=E2=80=9C-Wall -Werror=E2=80=9D are enabled, but there is no warning and =
compiler
may take advantage of uninit variable to do aggressive optimization.

In llvm internals, uninitialized variable usage may generate
'unreachable' IR insn and these 'unreachable' IR insns may indicate
uninit var impact on code optimization. With clang21 patch [2],
those 'unreachable' IR insn are converted to func bpf_unreachable().

In kernel, a new kfunc bpf_unreachable() is added. If this kfunc
(generated by [2]) is the last insn in the main prog or a subprog,
the verifier will suggest the verification failure may be due to
uninitialized var, so user can check their source code to find the
root cause.

Without this patch, the verifier will output
  last insn is not an exit or jmp
and user will not know what is the potential root cause and
it will take more time to debug this verification failure.

bpf_unreachable() is also possible in the middle of the prog.
If bpf_unreachable() is hit during normal do_check() verification,
verification will fail.

  [1] https://github.com/msune/clang_bpf/blob/main/Makefile#L3
  [2] https://github.com/llvm/llvm-project/pull/131731

Signed-off-by: Yonghong Song <yonghong.song@linux.dev>
---
 kernel/bpf/helpers.c  |  5 +++++
 kernel/bpf/verifier.c | 22 +++++++++++++++++++++-
 2 files changed, 26 insertions(+), 1 deletion(-)

In order to compile kernel successfully with the above [2], the following
change is needed due to clang21 changes:

  --- a/Makefile
  +++ b/Makefile
  @@ -852,7 +852,7 @@ endif
   endif # may-sync-config
   endif # need-config

  -KBUILD_CFLAGS  +=3D -fno-delete-null-pointer-checks
  +KBUILD_CFLAGS  +=3D -fno-delete-null-pointer-checks -Wno-default-const=
-init-field-unsafe

  --- a/scripts/Makefile.extrawarn
  +++ b/scripts/Makefile.extrawarn
  @@ -19,6 +19,7 @@ KBUILD_CFLAGS +=3D $(call cc-disable-warning, frame-a=
ddress)
   KBUILD_CFLAGS +=3D $(call cc-disable-warning, address-of-packed-member=
)
   KBUILD_CFLAGS +=3D -Wmissing-declarations
   KBUILD_CFLAGS +=3D -Wmissing-prototypes
  +KBUILD_CFLAGS +=3D -Wno-default-const-init-var-unsafe

diff --git a/kernel/bpf/helpers.c b/kernel/bpf/helpers.c
index c1113b74e1e2..4852c36b1c51 100644
--- a/kernel/bpf/helpers.c
+++ b/kernel/bpf/helpers.c
@@ -3273,6 +3273,10 @@ __bpf_kfunc void bpf_local_irq_restore(unsigned lo=
ng *flags__irq_flag)
 	local_irq_restore(*flags__irq_flag);
 }
=20
+__bpf_kfunc void bpf_unreachable(void)
+{
+}
+
 __bpf_kfunc_end_defs();
=20
 BTF_KFUNCS_START(generic_btf_ids)
@@ -3386,6 +3390,7 @@ BTF_ID_FLAGS(func, bpf_copy_from_user_dynptr, KF_SL=
EEPABLE)
 BTF_ID_FLAGS(func, bpf_copy_from_user_str_dynptr, KF_SLEEPABLE)
 BTF_ID_FLAGS(func, bpf_copy_from_user_task_dynptr, KF_SLEEPABLE | KF_TRU=
STED_ARGS)
 BTF_ID_FLAGS(func, bpf_copy_from_user_task_str_dynptr, KF_SLEEPABLE | KF=
_TRUSTED_ARGS)
+BTF_ID_FLAGS(func, bpf_unreachable)
 BTF_KFUNCS_END(common_btf_ids)
=20
 static const struct btf_kfunc_id_set common_kfunc_set =3D {
diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c
index f6d3655b3a7a..5496775a884e 100644
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@ -206,6 +206,7 @@ static int ref_set_non_owning(struct bpf_verifier_env=
 *env,
 static void specialize_kfunc(struct bpf_verifier_env *env,
 			     u32 func_id, u16 offset, unsigned long *addr);
 static bool is_trusted_reg(const struct bpf_reg_state *reg);
+static void verbose_insn(struct bpf_verifier_env *env, struct bpf_insn *=
insn);
=20
 static bool bpf_map_ptr_poisoned(const struct bpf_insn_aux_data *aux)
 {
@@ -3399,7 +3400,10 @@ static int check_subprogs(struct bpf_verifier_env =
*env)
 	int i, subprog_start, subprog_end, off, cur_subprog =3D 0;
 	struct bpf_subprog_info *subprog =3D env->subprog_info;
 	struct bpf_insn *insn =3D env->prog->insnsi;
+	bool is_bpf_unreachable =3D false;
 	int insn_cnt =3D env->prog->len;
+	const struct btf_type *t;
+	const char *tname;
=20
 	/* now check that all jumps are within the same subprog */
 	subprog_start =3D subprog[cur_subprog].start;
@@ -3434,7 +3438,18 @@ static int check_subprogs(struct bpf_verifier_env =
*env)
 			if (code !=3D (BPF_JMP | BPF_EXIT) &&
 			    code !=3D (BPF_JMP32 | BPF_JA) &&
 			    code !=3D (BPF_JMP | BPF_JA)) {
-				verbose(env, "last insn is not an exit or jmp\n");
+				verbose_insn(env, &insn[i]);
+				if (btf_vmlinux && insn[i].code =3D=3D (BPF_CALL | BPF_JMP) &&
+				    insn[i].src_reg =3D=3D BPF_PSEUDO_KFUNC_CALL) {
+					t =3D btf_type_by_id(btf_vmlinux, insn[i].imm);
+					tname =3D btf_name_by_offset(btf_vmlinux, t->name_off);
+					if (strcmp(tname, "bpf_unreachable") =3D=3D 0)
+						is_bpf_unreachable =3D true;
+				}
+				if (is_bpf_unreachable)
+					verbose(env, "last insn is bpf_unreachable, due to uninitialized va=
r?\n");
+				else
+					verbose(env, "last insn is not an exit or jmp\n");
 				return -EINVAL;
 			}
 			subprog_start =3D subprog_end;
@@ -12122,6 +12137,7 @@ enum special_kfunc_type {
 	KF_bpf_res_spin_unlock,
 	KF_bpf_res_spin_lock_irqsave,
 	KF_bpf_res_spin_unlock_irqrestore,
+	KF_bpf_unreachable,
 };
=20
 BTF_SET_START(special_kfunc_set)
@@ -12225,6 +12241,7 @@ BTF_ID(func, bpf_res_spin_lock)
 BTF_ID(func, bpf_res_spin_unlock)
 BTF_ID(func, bpf_res_spin_lock_irqsave)
 BTF_ID(func, bpf_res_spin_unlock_irqrestore)
+BTF_ID(func, bpf_unreachable)
=20
 static bool is_kfunc_ret_null(struct bpf_kfunc_call_arg_meta *meta)
 {
@@ -13525,6 +13542,9 @@ static int check_kfunc_call(struct bpf_verifier_e=
nv *env, struct bpf_insn *insn,
 			return err;
 		}
 		__mark_btf_func_reg_size(env, regs, BPF_REG_0, sizeof(u32));
+	} else if (insn->imm =3D=3D special_kfunc_list[KF_bpf_unreachable]) {
+		verbose(env, "unexpected hit bpf_unreachable, due to uninit var or inc=
orrect verification?\n");
+		return -EFAULT;
 	}
=20
 	if (is_kfunc_destructive(&meta) && !capable(CAP_SYS_BOOT)) {
--=20
2.47.1


