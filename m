Return-Path: <bpf+bounces-36208-lists+bpf=lfdr.de@vger.kernel.org>
X-Original-To: lists+bpf@lfdr.de
Delivered-To: lists+bpf@lfdr.de
Received: from sv.mirrors.kernel.org (sv.mirrors.kernel.org [IPv6:2604:1380:45e3:2400::1])
	by mail.lfdr.de (Postfix) with ESMTPS id B633F94424B
	for <lists+bpf@lfdr.de>; Thu,  1 Aug 2024 06:57:51 +0200 (CEST)
Received: from smtp.subspace.kernel.org (wormhole.subspace.kernel.org [52.25.139.140])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
	(No client certificate requested)
	by sv.mirrors.kernel.org (Postfix) with ESMTPS id 677C5283DF8
	for <lists+bpf@lfdr.de>; Thu,  1 Aug 2024 04:57:50 +0000 (UTC)
Received: from localhost.localdomain (localhost.localdomain [127.0.0.1])
	by smtp.subspace.kernel.org (Postfix) with ESMTP id C579413DDD5;
	Thu,  1 Aug 2024 04:57:44 +0000 (UTC)
X-Original-To: bpf@vger.kernel.org
Received: from 69-171-232-180.mail-mxout.facebook.com (69-171-232-180.mail-mxout.facebook.com [69.171.232.180])
	(using TLSv1.2 with cipher ECDHE-RSA-AES128-GCM-SHA256 (128/128 bits))
	(No client certificate requested)
	by smtp.subspace.kernel.org (Postfix) with ESMTPS id 83A0013D899
	for <bpf@vger.kernel.org>; Thu,  1 Aug 2024 04:57:41 +0000 (UTC)
Authentication-Results: smtp.subspace.kernel.org; arc=none smtp.client-ip=69.171.232.180
ARC-Seal:i=1; a=rsa-sha256; d=subspace.kernel.org; s=arc-20240116;
	t=1722488264; cv=none; b=jvmV+C9wUJ2gdy0HSaTBp152k9c4AHQGVicvclj8vqUiuQI7SQBdxGlbZXGcwLuuVabyXz4KWER89lqjNlaC43wzNDeGVAgepBXlB43YRZbQ6kK+av+U8KwS1Czd1Gv81eLikz2ce98XW3prCwO/vK+Uc13jCudpEifzdnj6SQQ=
ARC-Message-Signature:i=1; a=rsa-sha256; d=subspace.kernel.org;
	s=arc-20240116; t=1722488264; c=relaxed/simple;
	bh=+2A/BTgraciyW+z5GBjPU5j/ICW5DzaWHM0Riv/8/+g=;
	h=From:To:Cc:Subject:Date:Message-ID:MIME-Version; b=gesW8Cw0JZ9e7V+Dynv8M8t1Z/n2HEkM6wpbHTvA8lwx7e9hvZxZy2JrmSyHIFjguLUGc9m88u/Xq5PxRI0dsQLEtTQ59TzQk5id0ZFm3Td75RiAGWdlVdfxj14INg8Csm4afKCx48mosYo0ZVPRms5J/thaChKyYkbQGCL5rQI=
ARC-Authentication-Results:i=1; smtp.subspace.kernel.org; dmarc=fail (p=none dis=none) header.from=linux.dev; spf=fail smtp.mailfrom=linux.dev; arc=none smtp.client-ip=69.171.232.180
Authentication-Results: smtp.subspace.kernel.org; dmarc=fail (p=none dis=none) header.from=linux.dev
Authentication-Results: smtp.subspace.kernel.org; spf=fail smtp.mailfrom=linux.dev
Received: by devbig309.ftw3.facebook.com (Postfix, from userid 128203)
	id 8786A739B554; Wed, 31 Jul 2024 21:57:24 -0700 (PDT)
From: Yonghong Song <yonghong.song@linux.dev>
To: bpf@vger.kernel.org
Cc: Alexei Starovoitov <ast@kernel.org>,
	Andrii Nakryiko <andrii@kernel.org>,
	Daniel Borkmann <daniel@iogearbox.net>,
	kernel-team@fb.com,
	Martin KaFai Lau <martin.lau@kernel.org>
Subject: [PATCH bpf-next] selftests/bpf: Fix arena_atomics selftest failure due to llvm change
Date: Wed, 31 Jul 2024 21:57:24 -0700
Message-ID: <20240801045724.1259104-1-yonghong.song@linux.dev>
X-Mailer: git-send-email 2.43.0
Precedence: bulk
X-Mailing-List: bpf@vger.kernel.org
List-Id: <bpf.vger.kernel.org>
List-Subscribe: <mailto:bpf+subscribe@vger.kernel.org>
List-Unsubscribe: <mailto:bpf+unsubscribe@vger.kernel.org>
MIME-Version: 1.0
Content-Transfer-Encoding: quoted-printable

Peilen Ye reported an issue ([1]) where for __sync_fetch_and_add(...) wit=
hout
return value like
  __sync_fetch_and_add(&foo, 1);
llvm BPF backend generates locked insn e.g.
  lock *(u32 *)(r1 + 0) +=3D r2

If __sync_fetch_and_add(...) returns a value like
  res =3D __sync_fetch_and_add(&foo, 1);
llvm BPF backend generates like
  r2 =3D atomic_fetch_add((u32 *)(r1 + 0), r2)

But 'lock *(u32 *)(r1 + 0) +=3D r2' caused a problem in jit
since proper barrier is not inserted based on __sync_fetch_and_add() sema=
ntics.

The above discrepancy is due to commit [2] where it tries to maintain bac=
kward
compatability since before commit [2], __sync_fetch_and_add(...) generate=
s
lock insn in BPF backend.

Based on discussion in [1], now it is time to fix the above discrepancy s=
o we can
have proper barrier support in jit. llvm patch [3] made sure that __sync_=
fetch_and_add(...)
always generates atomic_fetch_add(...) insns. Now 'lock *(u32 *)(r1 + 0) =
+=3D r2' can only
be generated by inline asm. The same for __sync_fetch_and_and(), __sync_f=
etch_and_or()
and __sync_fetch_and_xor().

But the change in [3] caused arena_atomics selftest failure.

  test_arena_atomics:PASS:arena atomics skeleton open 0 nsec
  libbpf: prog 'and': BPF program load failed: Permission denied
  libbpf: prog 'and': -- BEGIN PROG LOAD LOG --
  arg#0 reference type('UNKNOWN ') size cannot be determined: -22
  0: R1=3Dctx() R10=3Dfp0
  ; if (pid !=3D (bpf_get_current_pid_tgid() >> 32)) @ arena_atomics.c:87
  0: (18) r1 =3D 0xffffc90000064000       ; R1_w=3Dmap_value(map=3Darena_=
at.bss,ks=3D4,vs=3D4)
  2: (61) r6 =3D *(u32 *)(r1 +0)          ; R1_w=3Dmap_value(map=3Darena_=
at.bss,ks=3D4,vs=3D4) R6_w=3Dscalar(smin=3D0,smax=3Dumax=3D0xffffffff,var=
_off=3D(0x0; 0xffffffff))
  3: (85) call bpf_get_current_pid_tgid#14      ; R0_w=3Dscalar()
  4: (77) r0 >>=3D 32                     ; R0_w=3Dscalar(smin=3D0,smax=3D=
umax=3D0xffffffff,var_off=3D(0x0; 0xffffffff))
  5: (5d) if r0 !=3D r6 goto pc+11        ; R0_w=3Dscalar(smin=3D0,smax=3D=
umax=3D0xffffffff,var_off=3D(0x0; 0xffffffff)) R6_w=3Dscalar(smin=3D0,sma=
x=3Dumax=3D0xffffffff,var_off=3D(0x0; 0x)
  ; __sync_fetch_and_and(&and64_value, 0x011ull << 32); @ arena_atomics.c=
:91
  6: (18) r1 =3D 0x100000000060           ; R1_w=3Dscalar()
  8: (bf) r1 =3D addr_space_cast(r1, 0, 1)        ; R1_w=3Darena
  9: (18) r2 =3D 0x1100000000             ; R2_w=3D0x1100000000
  11: (db) r2 =3D atomic64_fetch_and((u64 *)(r1 +0), r2)
  BPF_ATOMIC stores into R1 arena is not allowed
  processed 9 insns (limit 1000000) max_states_per_insn 0 total_states 0 =
peak_states 0 mark_read 0
  -- END PROG LOAD LOG --
  libbpf: prog 'and': failed to load: -13
  libbpf: failed to load object 'arena_atomics'
  libbpf: failed to load BPF skeleton 'arena_atomics': -13
  test_arena_atomics:FAIL:arena atomics skeleton load unexpected error: -=
13 (errno 13)
  #3       arena_atomics:FAIL

The reason of the failure is due to [4] where atomic{64,}_fetch_{and,or,x=
or}() are not
allowed by arena addresses. Without llvm patch [3], the compiler will gen=
erate 'lock ...'
insn and everything will work fine.

This patch fixed the problem by using inline asms. Instead of __sync_fetc=
h_and_{and,or,xor}() functions,
the inline asm with 'lock' insn is used and it will work with or without =
[3].

  [1] https://lore.kernel.org/bpf/ZqqiQQWRnz7H93Hc@google.com/T/#mb68d67b=
c8f39e35a0c3db52468b9de59b79f021f
  [2] https://github.com/llvm/llvm-project/commit/286daafd65129228e08a1d0=
7aa4ca74488615744
  [3] https://github.com/llvm/llvm-project/pull/101428
  [4] d503a04f8bc0 ("bpf: Add support for certain atomics in bpf_arena to=
 x86 JIT")

Signed-off-by: Yonghong Song <yonghong.song@linux.dev>
---
 .../selftests/bpf/progs/arena_atomics.c       | 57 +++++++++++++++++--
 1 file changed, 51 insertions(+), 6 deletions(-)

diff --git a/tools/testing/selftests/bpf/progs/arena_atomics.c b/tools/te=
sting/selftests/bpf/progs/arena_atomics.c
index bb0acd79d28a..611983446427 100644
--- a/tools/testing/selftests/bpf/progs/arena_atomics.c
+++ b/tools/testing/selftests/bpf/progs/arena_atomics.c
@@ -5,6 +5,7 @@
 #include <bpf/bpf_tracing.h>
 #include <stdbool.h>
 #include "bpf_arena_common.h"
+#include "bpf_misc.h"
=20
 struct {
 	__uint(type, BPF_MAP_TYPE_ARENA);
@@ -87,8 +88,22 @@ int and(const void *ctx)
 		return 0;
 #ifdef ENABLE_ATOMICS_TESTS
=20
-	__sync_fetch_and_and(&and64_value, 0x011ull << 32);
-	__sync_fetch_and_and(&and32_value, 0x011);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[and64_value], 0, 1);"
+		"lock *(u64 *)(r1 + 0) &=3D %[val]"
+		:
+		: __imm_ptr(and64_value),
+		  [val]"r"(0x011ull << 32)
+		: "r1"
+	);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[and32_value], 0, 1);"
+		"lock *(u32 *)(r1 + 0) &=3D %[val]"
+		:
+		: __imm_ptr(and32_value),
+		  [val]"w"(0x011)
+		: "r1"
+	);
 #endif
=20
 	return 0;
@@ -103,8 +118,23 @@ int or(const void *ctx)
 	if (pid !=3D (bpf_get_current_pid_tgid() >> 32))
 		return 0;
 #ifdef ENABLE_ATOMICS_TESTS
-	__sync_fetch_and_or(&or64_value, 0x011ull << 32);
-	__sync_fetch_and_or(&or32_value, 0x011);
+
+	asm volatile(
+		"r1 =3D addr_space_cast(%[or64_value], 0, 1);"
+		"lock *(u64 *)(r1 + 0) |=3D %[val]"
+		:
+		: __imm_ptr(or64_value),
+		  [val]"r"(0x011ull << 32)
+		: "r1"
+	);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[or32_value], 0, 1);"
+		"lock *(u32 *)(r1 + 0) |=3D %[val]"
+		:
+		: __imm_ptr(or32_value),
+		  [val]"w"(0x011)
+		: "r1"
+	);
 #endif
=20
 	return 0;
@@ -119,8 +149,23 @@ int xor(const void *ctx)
 	if (pid !=3D (bpf_get_current_pid_tgid() >> 32))
 		return 0;
 #ifdef ENABLE_ATOMICS_TESTS
-	__sync_fetch_and_xor(&xor64_value, 0x011ull << 32);
-	__sync_fetch_and_xor(&xor32_value, 0x011);
+
+	asm volatile(
+		"r1 =3D addr_space_cast(%[xor64_value], 0, 1);"
+		"lock *(u64 *)(r1 + 0) ^=3D %[val]"
+		:
+		: __imm_ptr(xor64_value),
+		  [val]"r"(0x011ull << 32)
+		: "r1"
+	);
+	asm volatile(
+		"r1 =3D addr_space_cast(%[xor32_value], 0, 1);"
+		"lock *(u32 *)(r1 + 0) ^=3D %[val]"
+		:
+		: __imm_ptr(xor32_value),
+		  [val]"w"(0x011)
+		: "r1"
+	);
 #endif
=20
 	return 0;
--=20
2.43.0


